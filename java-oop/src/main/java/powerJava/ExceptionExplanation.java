package powerJava;

public class ExceptionExplanation {

}


/*
 * 
 * 예외처리
 * 
 * 1. 예외처리란?
 * 
 * 프로그램의 오류를 자바에서는 예외라는 이름으로 부른다. 대게의 경우 오류가 발생하면 프로그램이 종료된다
 * 그러나 무조건 종료하는 것보다 프로그램에서 오류를 감지하여 우아하게 프로그램을 종료하거나 오류를 처리한
 * 후에 계속 실행할 수 있다면 더 나은 프로그램이 될 수 있다. 이것을 자바에서는 예외처리라고 한다.
 * 
 * 
 * 예외(exception)란 "exceptional event"의 약자이다. 즉 예외는 프로그램의 실행 중에 발생하는
 * 이벤트로서 프로그램의 정상적인 실행흐름을 중단시킨다. 메소드 안에서 오류가 발생하면 메소드는 발생된
 * 오류를 설명하는 객체를 생성하고 자바 런타임 시스템으로 이 객체를 넘긴다.
 * 
 * 이 객체는 예외객체(exception object)라고 불리며 오류의 타입과 오류 발생 시의 프로그램 상태 등의
 * 정보를 포함하고 있다. 예외객체를 생성하는 것을 흔히 예외를 던진다고 하고 예외객체를 처리하는 것을
 * 예외를 잡는다고 한다.
 * 
 * 참고사항: 버그와 예외
 * 
 * 버그와 예외는 구별하여야 한다. 실행 도중에 버그로 인해서도 실행 오류가 발생할 수 있지만 버그는
 * 개발 과정에서 모두 수정되어야 한다. 자바에서는 버그에 의한 실행 오류도 예외로 취급하지만 
 * 진정한 의미에서의 예외는 우리가 예상하였던 상황이 아닌 경우를 의미한다. 예를 들면 반드시
 * 존재하여야 하는 파일이 없거나 인터넷 서버가 다운된 경우 등을 진정한 의미에서의 예외라고 할 수 있다.
 * 
 * 예외처리기:
 * 
 * 자바에서 에외 처리기는 try블록과 catch 블록으로 이루어진다. 기본적으로 try 블록에서 발생된
 * 예외를 catch블록에서 처리한다,
 * 
 * try{
 * 		// 예외가 발생할 수 있는 코드
 * } catch{
 * 		// 예외를 처리하는 코드
 * }
 * finally {
 * 		// 여기 있는 코드는 try  블록이 끝나면 무조건 실행된다.
 * }
 * 
 * 
 * 
 * finally 블록:
 * 
 * finally 블록은 try-catch 블록이 종료될 때에 반드시 실행된다. finally 블록은 프로그래머가 실수로
 * 자원 정리를 하지 않고 try-catch 블록을 종료하는 것을 방지한다. 예를 들어 파일과 같은 자원을
 * 반납하는 코드는 항상 fianlly 블록을 넣는 것이 좋다.
 * 
 * 하나의 예로 printWriter 클래스의 객체를 생성하여 보자. 만약 생성하는 도중에 입출력 오류가
 * 발생하라 수 있는데, 오류가 발생하건 안하건 간에 반드시 printWriter 객체를 닫아야 한다고 가정하자.
 * 
 * try{
 * 		out = new PrintWirter(...);
 * }catch (IOException e) {
 * 		throw new RuntimeException(e);
 * }
 * out.close();
 * 
 * 이 경우, 만약 예외가 발생하는 경우 out.close() 호출이 이루어지지 않을 수도 있다.
 * 따라서,
 * 
 * try{
 * 		out = new PrintWirter(...);
 * }catch (IOException e) {
 * 		throw new RuntimeException(e);
 * } finally{
 * 		out.close();
 * }
 * 
 * 이렇게 finally 블록을 사용한다면 오류가 발생하더라도 out.close()가 호출되어
 * 자원은 항상 확실하게 반납된다. finally 블록을 적절하게 사용하면 자원의 누출을 막을 수 있다.
 * 
 * 
 * try-with-resources 문장:
 * 
 * try-with-resources 문장은 하나 이상의 자원을 선언하는 try 문장이다. 자원은 프로그램이
 * 종료되면서 반드시 닫혀야 한다. try-with-resources 문장은 문장의 끝에서 자원들이 자동으로 닫히게 한다.
 * 
 * 다음의 문장은 파일로부터 첫 번째 줄을 읽는다. BufferedReader 객체를 이용하여서 파일로부터 데이터를 읽는다.
 * BufferedReader 는 종료 시에 반드시 닫혀야 한다.
 * 
 * static String readFirstLineFromFile(String path) throws IOException {
 * 	try(BufferedReader br = new BufferedReader(new FileReader(path))){
 * 		//try키워드 바로 뒤에 괄호가 있으면 자원으로 취급한다. 즉 괄호 안이 resource임.
 * 		return br.readLine();
 * 	}
 * }
 * 
 * 위의 예제에서 try-with-resources 문장 안에 선언된 자원은 BufferedReader이다
 * BufferedReader 객체가 try-with-resource문장 안에 선언되었으므로 try 문장이
 * 정상적으로 종료되건 예외가 발생하건 간에 무조건 닫힌다.
 * 
 * 이 기능을 사용하려면 자원 객체가 java.lang.AutoCloseable 인터페이스를 구현하여야 한다.
 * Java 7부터는 BufferedReader 클래스가 이 인터페이스를 구현하고 있다.
 * 
 * 주의사항: try 와 catch 블록은 별도의 독립된 블록이다. 따라서 try 블록에서 정의된 변수는
 * catch 블록에서 사용할 수 없다.
 * 
 * 
 * 
 *
 *
 *
 *2. 예외처리자바에서 모든 예외가 처리되어야 하는 것은 아니다. 예외의 종류에 따라서 처리되지 않아도 되는
 *예외도 있다. 예외에는 Error, RuntimeException, 기타 예외 이렇게 3가지 종류가 있다.
 *
 *	- Error: 너무 심각해서 할 수 있는 일이 없음. 컴파일러가 통과시킴.
 *	- RuntimeException: 프로그래밍 버그이므로 스스로 고쳐야 함. 역시 통과
 *	- Error또는 RuntimeException도 아닌 예외: 반드시 처리해야 함. 컴파일러가 검사.
 *
 *
 * 첫 번쨰 종류는 Error이다 Error는 JVM 안에서 치명적인 오류가 발생하면 생성된다. 보통 애플리케이션은
 * 이러한 오류를 예측하거나 복구할 수 없다. 예를 들어서 하드웨어의 오류로 인하여 파일을 읽을 수 없는 경우이다.
 * 이런 경우에는 IOError가 발생한다. 애플리케이션은 이러한 Error를 잡아서 사용자에서 보고할 수는 있지
 * 다 이상 처리할 수는 없다. 따라서 애플리케이션을 종료시키는 것이 보통이다. 다행히 Error는 예외처리의
 * 대상이 아니다. 따라서 컴파일러가 체크하지 않는다.
 * 
 * 두 번째 종류는 RuntimeException이다. 이들은 주로 프로그래밍 버그나 논리 오류에서 기인한다. 예를 들면
 * 파일 이름을 FileReader 생성자로 전달하는 과정에서 논리오류로 항상 null 값을 전달한다면 
 * nullPointerException을 발생한다. 애플리케이션은 이러한 예외를 물론 잡아서 처리할 수 있지만
 * 보다 합리적인 방법은 예외를 일으킨 버그를 잡는 것이다. 따라서 RuntimeException도 예외 처리의
 * 주된 대상이 아니다. 따라서 컴파일러가 체크하지 않는다. Error와 RuntimeException을 합쳐서
 * 비체크 예외 (unchecked exception)라고 한다. p514 참고
 * 
 * 
 *세 번째 종류는 Error와 RuntimeException을 제외한 나머지 예외이다.
 *이들은 체크예외(checked exception)라고 불린다. 이 예외들은 충분히 예견될 수 있고 회복할 수 있는
 *예외이므로 프로그램은 반드시 이 예외를 처리해야 한다. 예를 들어 애플리케이션이 사용자에게 입력 파일 이름을 받아서
 *파일을 오픈하는 상황을 가정하자. 정상적으로는 사용자가 이미 존재하는 파일 이름을 입력하고 FileReader객체가
 *정상적으로 생성될 것이다. 그러나 만약 사용자가 실수로 잘못된 파일 이름을 입력한다면 FileNotException 예외가
 *발생한다. 노렪나 프로그래머라면 이 예외를 잡아서 사용자에게 정확한 파일 이름을 다시 입력하도록 요청할 것이다.
 *이 체크 예외가 바로 우리가 학습하는 예외 처리의 주된 대상이 된다. 체크 예외는 컴파일러가 예외를 처리했는지를
 *확인한다. 만약 처리하지 않았으면 컴파일 오류가 발생한다.
 * 
 * 
 * 
 * 
 * 
 * 3. 예외와 메소드
 * 
 * 자바에서 예외를 처리하는 방법에는 한 가지가 더 있다.
 * 
 *  - 예외를 잡아서 그 자리에서 처리하는 방법: try-catch 블록을 사용해서 예외를 잡고 처리한다.
 *  - 메소드가 예외를 발생시킨다고 기술하는 방법: throws를 사용하여, 다른 메소드한테 예외 처리를 맡긴다.
 * 
 * 
 * 메소드가 예외를 발생시킨다고 기술하는 방법
 * 
 * 앞에서는 try-catch 블록을 이용하여서 예외를 잡아 처리하였다. 하지만 가끔은 메소드가 발생되는 예외를
 * 그 자리에서 처리하지 않고, 자신을 호출한 상위 메소드로 예외를 전달하는 편이 더 적절할 수도 있다.
 * 발생하는 모든 예외를 그 자리에서 처리하는 것은 상당한 양의 코드를 필요로 하고 또 반드시 상위 메소드가
 * 그 예외를 처리하도록 해야 하는 경우도 있다.
 * 
 * 만약 발생하는 예외를 바로 처리하지 않으려면 반드시 메소드가 이들 예외를 던진다고 메소드 정의에 표시하여야
 * 한다. 예를 들어서 1절의 예제 FileError.java의 writeList() 메소드 안에서 예외를 처리하지 않으면
 * 컴파일 오류가 발생한다.
 * 
 * 
 * public void writeList(){
 * 	PrintWriter = new PrintWriter(new FileWriter("outfile.txt")); // 오류발생
 * 		for(int i = 0; i < SIZE; i++)
 * 			out.println("배열 원소" + i + "=" + list[i]);
 * 	out.close();
 * }
 * 
 * 이 컴파일 오류를 해결하려면 다음과 같이 메소드가 오류를 발생시킨다고 기술해 주면 된다.
 * 
 * public void writeList() throws IOException {
 * 	 // IOException 예외를 던질 수 있는 메소드라는 것을 기술한다.
 * }
 * 
 * writeList() 안에서는 ArrayIndexOutOfBoundsException 예외도 발생할 수 있지만
 * 이것은 비체크 예외이므로 상위 메소드로 전달하지 않아도 된다. 물론 다음과 같이 기술할 수도 있다.
 * 
 * public void writeList() throws IOException, ArrayIndexOutOfBoundsException{
 * 
 * }
 * 
 * 
 * 예외 발생 메소드 정의:
 * 
 * 본질적으로 어떤 메소드는 작업 중에 예외가 발생할 수 있다. 예를 들어서 파일을 오픈하는 메소드는
 * 하드 디스크에 파일이 없다면 예외가 발생할 것이다. 네트워크 관련 메소드는 만약 서버가 다운되면
 * 예외가 발생하게 된다. 예외를 발생시킬 수 있는 메소드는 자신을 호출한 메소드에게 이것을 알려주어야 한다.
 * 그래야만 자신을 호출한 메소드가 예외를 처리하는 코드를 준비할 수 있다. 키워드 throws는 메소드가 
 * 발생할 수 있는 예외들을 나열하는 데 사용된다.
 * 
 * int sub() throws a,b //sub()가 a와 b라는 예외를 발생시킬 수 있음을 나타낸다.
 * {
 * 
 * }
 * 
 * 그러나 메소드 안에서 발생되는 모든 예외를 나열해야 하는 것은 아니다. 앞에서 설명하였뜻이 비체크 예외인
 * Error와 RuntimeException은 열거될 필요가 없다. 보통 RuntimeException은 프로그램의 다른
 * 영역으로 넘기지 말고 직접 처리해야 한다.
 * 
 * 
 * 
 * 예외 처리 과정:
 * 
 * 자바 런타임 시스템에서 예외를 처리하는 절차에 대해 자세히 알아보자. 어떤 메소드 안에서 예외가 발생하면
 * 런타임 시스템은 그 메소드 안에 예외 처리기가 있는지를 살핀다. 만약 그 자리에 예외 처리가가 없다면
 * 호출 스택(call stack)에 있는 상위 메소드를 조사하게 된다. 예를 들어서 다음과 같은 순서로 메소드가
 * 호출 되었다면 호출스택은 다음과 같다.
 * 
 * 		예외발생↓	writeList() : 오류가 발생한 메소드. 예외처리기 없음
 * 				-----------------------------------------
 * 		예외전달↓	sub2() : 예외처리기가 없는 메소드				  ↑ 메소드 호출
 * 				-----------------------------------------
 * 		예외잡기↓	sub1() : 예외처리기 존재. 여기서 에러 처리		  ↑ 메소드 호출
 * 				-----------------------------------------
 * 				main() --> 								  ↑ 메소드 호출
 * 				-----------------------------------------
 * 
 * 이 상태에서 writeList()에서 예외가 발생하였다고 가정하자. 자바 런타임 시스템은 호출 스택에서
 * 예외 처리기를 가지고 있는 메소드를 탐색한다. 탐색은 예외가 발생한 메소드부터 시작하여서 메소드가
 * 호출된 순서의 역순으로 진행된다. 만약 적절한 처리기가 발견되면 런타임 시스템은 예외를 그 처리기에
 * 넘긴다. 적절하다는 것은 예외의 종류과 처리기가 처리하기로 한 예외의 종류가 일치하는 것을 의미한다.
 * 만약 전체 호출 스택을 뒤졌는데도 처리기를 발견하지 못하면 런타임 시스템이 그냥 프로그램을 종료시킨다.
 * 
 * 
 * 
 * 
 * 
 * 5. 예외 처리의 장점
 * 
 * 지금까지 우리는 자바에서의 예외 처리에 대하여 학습하였다. 여기서 자바에서의 예외 처리 방식의 
 * 장점을 잠까 생각하여 보자. 여기서는 자바 튜토리얼에 등장한 예제를 수정하여 사용하였고 좀 더
 * 자세한 내용은 자바 튜터리얼을 참고하기 바람.
 * 
 * 오류코드를 정상적인 코드와 분리할 수 없다.
 * 
 * 
 *  
 * 
 * 
 * 
 */